# Optimal Binary Search Tree (OBST) алгоритмын тайлбар:
#
# Энэ алгоритм нь өгөгдсөн түлхүүрүүд (keys) болон тэдгээрийн давтамж (freq)-ийн үндсэн дээр 
# оновчтой хоёртын хайлтын модыг үүсгэж, хайлтын нийт зардлыг хамгийн бага байлгах зорилготой.
# Алгоритм нь динамик программчлалыг ашиглан хамгийн бага зардлыг тооцоолно.
#
# Алгоритмын үндсэн алхмууд:
#
# 1. **Өгөгдөл бэлтгэх:**
#    - `keys`: Хайлтын түлхүүрүүдийн жагсаалт.
#    - `freq`: Түлхүүрүүдийн давтамж буюу хайлтын магадлалын жагсаалт.
#    - `n`: Түлхүүрүүдийн тоо.
#
# 2. **Динамик хүснэгт үүсгэх:**
#    - `dp[i][j]`: i-ээс j хүртэлх түлхүүрүүдээс бүтсэн модны хамгийн бага зардлыг хадгалах 2 хэмжээст хүснэгт.
#    - `cumulative_freq`: Түлхүүрүүдийн давтамжийн нийлбэрийг хурдан тооцоолоход ашиглагдана.
#
# 3. **Туслах функц (`get_sum`):**
#    - `get_sum(i, j)` функц нь i-ээс j хүртэлх түлхүүрүүдийн давтамжийн нийлбэрийг хурдан тооцоолно.
#
# 4. **Динамик хүснэгтийг дүүргэх:**
#    - Зөвхөн ганц түлхүүртэй модны зардлыг `freq[i]` гэж анхны утгаар оруулна.
#    - Хоёр болон түүнээс дээш түлхүүртэй модны зардлыг олж, хамгийн бага зардлыг сонгоно.
#    - Зардлыг тооцоолохдоо модны үндэс (root)-ийг өөр өөр түлхүүрүүдээр туршиж үзнэ.
#
# 5. **Хариу буцаах:**
#    - `dp[0][n-1]`: Бүх түлхүүрийг ашиглан бүтээсэн модны хамгийн бага зардал.
#
# Алгоритмын хугацааны төвөгшил: O(n^3) 
# Учир нь 3 давхар давталт ашиглаж байгаа.

def optimal_bst(keys, freq):
    n = len(keys)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    cumulative_freq = [0] * (n + 1)


    for i in range(1, n + 1):
        cumulative_freq[i] = cumulative_freq[i - 1] + freq[i - 1]

    def get_sum(i, j):
        return cumulative_freq[j + 1] - cumulative_freq[i]


    for i in range(n):
        dp[i][i] = freq[i]

    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')
            for r in range(i, j + 1):
                cost = (dp[i][r - 1] if r > i else 0) + \
                       (dp[r + 1][j] if r < j else 0) + \
                       get_sum(i, j)
                dp[i][j] = min(dp[i][j], cost)

    return dp[0][n - 1]


keys = [5, 6]
freq = [17, 25]


result = optimal_bst(keys, freq)
print("Хамгийн бага хайлтын зардал:", result)